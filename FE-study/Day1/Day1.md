### 📌 [W3C](http://www.w3c.org)는 뭐하는 곳인가요?

- 웹(Web)을 위한 표준을 개발하고 장려하는 조직
- 사용자가 어떠한 운영체제나 브라우저를 사용하더라도 **웹페이지가 동일하게 보이고 정상적으로 작동** 할 수 있도록 하는 웹 페이지 제작 기법
- CSS, HTML, XML 등 문서양식 표준화

표준이 정의되는 단계

1. **Working Draft (WD) : 초안**
    
    W3C가 그 멤버 뿐만 아니라 대중, 다른 기술단체 등 여러 커뮤니티에 검토를 받기 위해 공개한 문서이다. 전부는 아니겠지만 Working Draft는 Recommendation로 발전하기 위한 첫 단계이다.
    
2. **Candidate Recommendation (CR) : 후보권고안**
    
    광범위하게 검토를 받았고 워킹그룹의 기술적인 요구사항을 만족했다고 믿는 문서로서, W3C는 더 많은 구현 경험을 얻기 위해 이 문서를 공개한다.
    
3. **Proposed Recommendation (PR) : 제안권고안**
    
    광범위한 기술적인 구현과 검토가 끝난 거의 완성된 문서로서, 최종 승인을 얻기 위해 자문위원회에 보낸다.
    
4. **3C Recommendation(REC) : 권고안**
    
    모든 합의를 끝낸 후 W3C멤버들과 감독에게 승인을 받은 문서로서, W3C는 이 문서가 널리 쓰이기를 권장한다. W3C Recommendation는 다른 기관이 공개한 표준과 비슷하다.
    

웹 표준이란? 

- 웹에서 표준적으로 사용되는 기술 또는 규칙
- 표준화 단체인 w3c가 권고한 표준안에 따라 웹사이트를 작성해야한다.
    - http://www.smartebiz.kr/new/subpage02_02.html
- 장점
    1. **수정 및 운영관리 용이:** 콘텐츠의 올바른 구조화와 CSS로 시각표현을 통일하여 제어하게 되어 페이지 제작의 부담 감소 및 관리용이
    2. **접근성 향상:** 웹 표준을 이용해 작성한 문서는 다양한 브라우징 환경에 대응이 가능하며 휴대폰, PDA에서도 정상적인 작동 및장애인 지원용 프로그램에도 도움이 되므로 사용자나 접속 장치의 접근성이 용이
    3. **검색엔진 최적화(SEO):** 구조화된 웹페이지는 검색 로봇 수집을 통해 검색엔진에 효율적으로 노출 될 수 있도록 검색엔진의 검색결과를 최적화
    4. **File Size 축소, 서버 저장 공간 절약:** 효율적인 소스 작성은 파일 사이즈와 서버공간을 절약할 수 있으며 동시에 화면표시에 소요되는 시간을 단축
    5. **효율적인 마크업:** CSS와 HTML문서를 분리하여 제작할 경우 불필요한 마크업이 최소화되어 페이지 로딩속도 향상
    6. **호환성 가능:** 기존 IE브라우저에서만 작동이 가능했던 요소들이 웹 표준을 준수함으로써 다양한 브라우저(크롬, 파이어폭스, 사파리, 오페라 등)에서도 작동

웹 접근성이란?

- 정보통신접근성 (Web 접근성)은 「지능정보화기본법」에 따라 장애인이나 고령자분들이 웹 사이트에서 제공하는 정보를 비장애인과 동등하게 접근하고 이용 할 수 있도록 보장하는 것으로 웹 접근성 준수는 법적의무사항 입니다.
1. 인식의 용이성 (Perceivable) : 모든 콘텐츠는 사용자가 인식할 수 있어야 한다.
2. 운용의 용이성(Operable) : 사용자 인터페이스 구성요소는 조작 가능하고 내비게이션 할 수 있어야 한다.
3. 이해의 용이성(Understandable) : 콘텐츠는 이해할 수 있어야 한다.
4. 견고성(Robust) : 웹 콘텐츠는 미래의 기술로도 접근할 수 있도록 견고하게 만들어야 한다.

---

### 📌 자바스크립트 표준은??

- ECMAScript
    
    다양한 웹 브라우저들에서 JavaScript가 공통되게 잘 작동되기 위해 **표준 규격이 필요성**이 커짐 → ECMA 국제 기구에서는 'ECMAScript standard'라는 스크립트 표준을 만듦
    
    즉, `ECMAScript`는 ECMA 인터내셔널에 의해 제정된 ECMA-262 기술 규격에 의해 정의된 범용 스크립트 언어(= ECMAScript 사양 (ECMAScript specification))
    
    ex. 
    
    - 우리가 쓰는 언어: **국어** - **javascript**
    - 우리가 일상생활에서 쓰는 언어의 기준이 되는 국어: **표준어** - **ECMA-262**
    - 표준어를 관리하는 곳: **국립국어원** - **ECMA 인터내셔널**
    - 국립국어원이 정한 표준어의 여러가지 규칙들**: 발음 또는 맞춤법** - **ECMAScript**
- ES6 란
    - `ES6`는 ECMA라는 국제 기구에서 만든 표준문서인 **ECMAScript(=ES)의 6번째 개정판 문서에 있는 표준 스펙**을 말합니다
    - 왜 es6가 유명한거야?
        - **새로운 문법 추가**: 화살표 함수(arrow function), 클래스(class), 템플릿 리터럴(template literals), 해체 할당(destructuring assignment), 기본 매개변수(default parameters), 확장 연산자(spread operator) 등
            - https://github.com/baeharam/Must-Know-About-Frontend/blob/main/Notes/javascript/es6.md
        - **모듈 시스템의 표준화**: ES6에서는 모듈(import/export)이 공식적으로 도입되어 JavaScript 코드를 더 잘 구성하고 관리할 수 있게 됨
        - **향상된 변수 선언**: `let`과 `const` 키워드가 도입되어 변수의 스코프와 생명주기를 더 명확하게 관리할 수 있게됨 →`const`를 사용하여 불변성(immutability)을 보장할 수 있어서 프로그램의 안정성을 높이는 데 기여
        - **화살표 함수**: 함수 표현을 더 짧고 간결하게 만들어 주며, `this`의 동작을 더 명확하게 정의
        - **프로미스(Promises)**: 비동기 코드를 더 깔끔하게 처리할 수 있는 프로미스 객체가 도입되어, 콜백 지옥(callback hell)을 피할 수 있음
        - **배열과 객체의 향상된 기능**: 배열의 메서드(map, filter, reduce 등)와 객체의 향상된 프로퍼티 선언 방식(Computed property names 등) 추가
        - **클래스**: ES6에서는 클래스(class) 문법이 도입되어 기존의 프로토타입 기반 상속보다 더 직관적이고 자바나 다른 객체지향 언어와 비슷한 방식으로 객체를 정의하고 상속할 수 있음
- ES7 이후
    - https://velog.io/@kyusung/after-es6

---

### 📌 (작성중) 브라우저에 [https://www.naver.com](https://www.naver.com/) 입력 후 화면에 렌더링 되기까지의 **모든 과정**

- URL을 웹 브라우저의 주소창에 입력한다.
- 웹 브라우저가 URL을 해석하고, 문법에 맞지 않으면 기본 검색엔진으로 검색한다.
- 문법에 맞으면 URL의 호스트 부분을 인코딩한다.
- HSTS(HTTP Strict Transport Security) 목록을 확인하고 있으면 HTTPS로, 없으면 HTTP로 요청한다.
- DNS(Domain Name Server) 조회
    - 브라우저/로컬 캐시 확인해서 도메인에 해당하는 IP가 있는지 확인한다.
    - 없으면 OS에게 DNS 서버에 요청하라고 지시한다.
    - DNS 서버는 해당 도메인에 해당하는 IP를 돌려준다.
- TCP 소켓을 열고 3-way handshake로 연결을 설정한다.
- HTTPS 요청이라면 TLS(Transport Layer Security) handshake 과정을 통해 세션키를 생성한다.
- 세션이 유지되는 동안 서버에게 요청하고 응답을 받는 과정을 반복한다.
    - 응답 상태코드에 따라 다르게 처리한다.
    - 응답을 디코딩(Decoding)하고 캐싱 가능하다면 캐싱한다.
- 웹브라우저는 응답받은 HTML/CSS/JS 및 이미지,폰트 등의 리소스를 사용하여 렌더링 한다.
- 서버와의 세션이 종료되면 4-way handshake로 연결을 종료한다.

---

### 📌 Virtual Dom 이란?

- DOM(Document Object Model)
    
    웹 페이지나 웹 앱에 있는 HTML 요소들을 트리형태의 구조
    
- 실제 DOM을 모방하는 형태로 메모리 상에서만 존재
- Diffing Algorithm
    - 변경이 발생할 때마다 가상의 DOM 트리를 만들어 이전 트리 스냅샷과 최신 트리 스냅샷을 비교(diff)하고 변경된 내용만 DOM에 반영
        - ld element tree와 new element tree를 비교하여 바뀐 element만 new element로 갱신
- 장점
    - JavaScript 객체 형태로 메모리 안에 저장 (→메모리 상에서 동작하기에 훨씬 더 빠르게 동작)
    - 실제 렌더링이 되지 않기 때문에 연산 비용이 적음 (→ 실제 브라우저 화면에 접근하는 것이 아니라서)
- DOM이 virtual DOM보다 무조건 빠른 건 아님!!
    - 복잡한 SPA(싱글 페이지 어플리케이션)에서는 DOM조작이 많이 발생 → 브라우저가 연산을 여러번 하는 비효율적인 프로세스 → Virtual DOM을 이용하는게 더 효율적

### 📌 Svelte는 virtual DOM을 사용하지 않는데 차이점

- svelte는 코드를 작성하면 컴파일 시점에 바닐라스크립트로 바꾸는데, 이때 어느 부분이 바뀌어야 되는지를 미리 정의해둠 → '이 값이 바뀌면 여기 돔이고 저 값은 저기 돔이고' 하는 코드들이 미리 정의 되어 있어 가상DOM을 사용하지 않아도 됨

---

### 📌 cors란?

- 등장 배경
    - **SOP**(Same-origin policy, 동일 출처 정책)
        
        자바스크립트 엔진 표준 스펙의 보안 규칙으로 하나의 출처(Origin)에서 로드된 자원(문서나 스크립트)이 호스트나 프로토콜, 포트번호가 일치하지 않는 자원과 상호작용 하지 못하도록 요청 발생을 제한하고, 동일 출처(Same Origin)에서만 접근이 가능한 정책
        
    
    SOP는 같은 origin을 가진 리소스만 접근이 가능하도록 제한 → CORS는 도메인 또는 포트가 서로 다른 origin 간에 리소스를 전달하는 방식을 제어하는 매커니즘
    
    - Origin이란?
        
        *Protocol, Hostname, Port*를 합쳐놓은 것
        
    
- **교차 출처 리소스 공유**(Cross-Origin Resource Sharing, [CORS](https://developer.mozilla.org/ko/docs/Glossary/CORS))란?
    - 추가 [HTTP](https://developer.mozilla.org/ko/docs/Glossary/HTTP) 헤더를 사용하여, 한 [출처](https://developer.mozilla.org/ko/docs/Glossary/Origin)에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제
    - 목적: CORS는 웹 보안을 강화하면서도, 다른 도메인 간 자원 공유를 가능하게 함으로써, 웹 애플리케이션의 기능성과 유연성을 유지할 수 있도록 함. 이를 통해 개발자는 여러 출처에서 데이터를 가져오거나 서비스를 이용할 수 있는 환경을 제공받을 수 있다.
- 해결방법
    - SOP에 위반 되는 상황 속에서도 리소스에 접근하려면, CORS 헤더를 도입
    - Proxy Server 도입
- CORS 관련 헤더
    - **Access-Control-Allow-Origin**: 허용된 출처 (Origin)를 지정
        - 헤더가 없거나 '*' 와일드카드를 사용하면 모든 출처에서 요청을 허용
    - **Access-Control-Allow-Methods**: 허용된 HTTP 메서드를 지정 (예: GET, POST 등).
    - **Access-Control-Allow-Headers**: 허용된 요청 헤더를 지정
    - **Access-Control-Allow-Credentials**: 클라이언트에서 쿠키를 포함한 인증 정보를 사용할 수 있는지 여부를 지정
    - **Access-Control-Expose-Headers**: 브라우저에 응답으로 반환할 사용자 지정 헤더를 지정

---

### 📌 **CJS와 ESM의 차이점**

- CJS와 ESM가 생겨나게된 근간
    
    > 초창기 JS 에는 모듈별로 코드를 가져오거나, 내보내는 방법이 없어, 하나의 JS 파일에 모든 기능을 담아야 했다. 이러한 문제는 점차 시간이 지날수록 가독성이 떨어지고, 동일 변수 사용으로 인한 에러가 나타나는 결과를 초래하기도 했다. 더불어 node.js를 통해 JS 가 서버 사이드에서도 영향을 미치기 시작하며 모듈 시스템에 대한 고민이 생겨났고, 오늘날 사용하고 있는 CJS, ESM이 등장하게 되었다.
    > 
    
    > 애플리케이션의 규모가 작을 때는 괜찮지만 크기가 커지면 유지보수와 재사용을 위해 여러 파일로 분리하는 것이 효율적이다. 이 분리된 파일을 **모듈**이라고 부른다.
    > 
    
    > 그리고 이러한 모듈을 효과적으로 불러오고 모듈 단위로 구성해주는 AMD, UMD, CommonJS와 같은 라이브러리들이 등장하게 된다. 이 중 CommonJS는 Node.js 서버를 위해 만들어진 모듈 시스템으로 엄밀히 말하자면 표준 시스템은 아니다.
    > 
    
    > ES6 이후에 ES Modules이 등장하고 표준으로 등록되며 익숙한 `import`, `export` 키워드를 사용해 모듈을 효과적으로 사용할 수 있게 되었다. 결과적으로 모듈의 개발로 SPA를 고통받지 않고 구현할 수 있게 되었다.
    > 
    
- 모듈이 분석되고 시행되는 생명 주기
    
    > 파싱 → 분석 → 번들링 → 컴파일 → 실행(런타임)
    > 
- **CommonJS (CJS)**

```jsx
// add.js
module.exports.add = (x, y) => x + y;

// main.js
const { add } = require('./add');

add(1, 2);
```

- **ECMAScript Modules (ESM)**

```jsx
// add.js
export function add(x, y) {
  return x + y
}

// main.js
import { add } from './add.js';

add(1, 2);
```

| 특성 | CommonJS | ESM (ECMAScript Modules) |
| --- | --- | --- |
| 사용 환경 | Node.js | 브라우저와 Node.js |
| 모듈 정의 | module.exports 또는 exports | export 키워드 |
| 모듈 불러오기 | require 함수 | import 키워드 |
| 로딩 방식 | 동기적 | 비동기적 (https://nodejs.org/api/esm.html#top-level-await을 지원) |
| 표준화 | 비표준 (Node.js에서 사용) | ES6 표준의 일부 |
| 분석시점 | 실행(런타임) 시 | 컴파일 시점에서 분석 |
| 기본 내보내기 | module.exports = value | export default value |
| 다중 내보내기 | exports.name = value | export const name = value |
| 파일 확장자 | .js (일반적으로) | .mjs (명확하게 구분할 때 사용) |
| 상호작용 | require 호출 시 평가됨 | import 호출 시 평가됨 |
| 사용 사례 | 서버 사이드 (Node.js) | 클라이언트 사이드 및 서버 사이드 |
| 버전 관리 | Node.js 모듈 시스템 | 최신 JavaScript 표준에 맞춤 |
- ESM에서 CJS `import`  가능 but CJS에서 ESM을 `require` 불가능(→ CJS는 [Top-level Await](https://fe-developers.kakaoent.com/2022/220728-es2022/)을 지원하지 않기 때문)
    - https://github.com/nodejs/node/issues/21267 ~~나중에 읽어보기~~
- CommonJS는 트리 셰이킹(Tree Shaking)(=사용되지 않는 코드를 제거하여 번들 크기를 줄이는 기술)이 어렵다는 단점이 있다. 반면, ES Module은 트리 셰이킹이 가능하다. (→ ES Module은 [정적 분석](https://ko.wikipedia.org/wiki/%EC%A0%95%EC%A0%81_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8_%EB%B6%84%EC%84%9D)이 가능하기 때문)

---

### 📌 null vs undefined

- 둘 다 JS의 데이터 타입(Number, BigInt, String, Null, Undefined, Boolean, Symbol)
    - `undefined` 값은 `undefined` 가 유일
    - `null` 값은 `null` 이 유일
    - null도 undefined도 값이다! (→ 변수 영역 메모리에 자리를 차지함)
    
    ```jsx
    console.log(null == undefined);   // true -> 
    console.log(null === undefined);  // false
    ```
    
- `undefined` : 값을 선언 후 할당하지 않은 변수에 자동 할당
    - ex) 메서드와 선언에 변수가 할당받지 않은 경우, 함수가 값을 return 하지 않았을 경우
    
    ```jsx
    console.log(typeof undefined); // "undefined"
    ```
    
- `null` :  어떤 값이 **의.도.적.** 으로 비어있음을 표현 (=변수가 특정 값이나 객체를 참조하지 않음) → null이 할당된 이후에 생김
    
    ```jsx
    console.log(typeof null); // "object" -> javaScript에서는 구현 버그로 간주
    ```
    

---

`||` vs `??` 

- `||`는 [falsy](https://developer.mozilla.org/ko/docs/Glossary/Falsy) 값을 만나면 오른쪽 피연산자를 반환
- `??`는 `null` 또는 `undefined` 값을 만나면 오른쪽 피연산자를 반환

```jsx
let a = 0;
let b = "Hello";

let result = a || b;  // "Hello"
let result2 = a ?? b; // 0
```

---

### 🔗 참고

W3C는 뭐하는 곳인가요??

- http://www.smartebiz.kr/new/subpage02_02.html
- https://velog.io/@abc2752/web-standard
- https://wit.nts-corp.com/2013/10/16/280
- https://www.wa.or.kr/m1/sub1.asp

브라우저에 [https://www.naver.com](https://www.naver.com/) 입력 후 화면에 렌더링 되기까지의 **모든 과정**

- https://velog.io/@sunohvoiin/브라우저의-렌더링-과정-www.google.com을-입력했을-때-일어나는-일
- https://velog.io/@khy226/브라우저에-url을-입력하면-어떤일이-벌어질까

Virtual Dom 이란??

- https://www.choegyumin.com/why-is-svelte-fast/

cors란??

- https://www.youtube.com/watch?v=bW31xiNB8Nc&t=15s
- https://developer.mozilla.org/ko/docs/Web/HTTP/CORS
- https://velog.io/@beomdrive/CORS-그-속으로

CJS vs ESM

- https://toss.tech/article/commonjs-esm-exports-field
- https://mxx-kor.github.io/blog/module-cjs-esm
- https://tech.kakao.com/posts/605
- https://velog.io/@pengoose_dev/CJS와-ESM

null vs undefined

- https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures
- https://www.yalco.kr/@javascript/2-1/
- https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_management
